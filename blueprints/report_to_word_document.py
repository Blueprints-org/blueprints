"""Module to convert Report to a Word document."""

import re

import latex2mathml.converter
import mathml2omml
from docx import Document
from docx.document import Document as DocumentObject
from docx.enum.style import WD_STYLE_TYPE
from docx.oxml import parse_xml
from docx.oxml.xmlchemy import BaseOxmlElement
from docx.shared import Inches, Pt, RGBColor
from docx.text.paragraph import Paragraph

from blueprints.codes.report import LatexReport


class ReportToWordConverter:
    r"""
    Converter to transform a Report (with text blocks, equations, titles, sections, tables) to a Word Document.

    Please note: this feature is not intended to be a full LaTeX to Word converter, but rather to handle
    the specific LaTeX constructs generated by the Report class. It is therefore recommended to
    use the Report class to create the LaTeX content for best compatibility.

    Limitations and Usage Notes:
    - Text blocks using \text{...} (can also be \textbf{...} and/or \textit{...} for bold/italic).
    - Equations in \begin{equation}...\end{equation} environments (with optional \tag{...}).
    - Titles, sections, subsections, and subsubsections using \title{...}, \section{...}, \subsection{...}, \subsubsection{...}.
    - Tables in \begin{table}...\end{table} environments with tabular content
    - Figures in \begin{figure}...\end{figure} environments with \includegraphics.
    - Bullet lists in \begin{itemize}...\end{itemize} environments with \item for each bullet.
    - Numbered lists in \begin{enumerate}...\end{enumerate} environments with \item for each item.
    - Inline equations (not in equation environments) between $...$.
    - New lines indicated by \newline.
    - Uses styles from the template.

    """

    def __init__(self) -> None:
        """Initialize the converter and optionally convert LaTeX to a Document."""
        self.template_docx: str | None = None

    @staticmethod
    def _set_style(para: Paragraph, style_name: str) -> None:
        """Set the style for a paragraph, creating it if it doesn't exist.

        Args:
            para: The paragraph object to apply the style to.
            style_name: The name of the style to apply.
        """
        doc = para._parent._parent if hasattr(para, "_parent") else para._element.getparent().getparent()  # noqa: SLF001

        # Try to apply the style
        try:
            para.style = style_name
        except KeyError:
            # Style doesn't exist, create it
            styles = doc.styles

            # Create the new style based on 'No Spacing' as a base
            try:
                new_style = styles.add_style(style_name, WD_STYLE_TYPE.PARAGRAPH)
                new_style.base_style = styles["No Spacing"]

                # Configure style based on its name
                if style_name == "title":
                    new_style.font.name = "Bebas Neue"
                    new_style.font.size = Pt(36)
                    new_style.font.bold = True
                    new_style.font.color.rgb = RGBColor(0x00, 0x28, 0x55)
                    new_style.paragraph_format.space_before = Pt(8)
                    new_style.paragraph_format.space_after = Pt(4)
                elif style_name == "section":
                    new_style.font.name = "Bebas Neue"
                    new_style.font.size = Pt(24)
                    new_style.font.bold = True
                    new_style.font.color.rgb = RGBColor(0x00, 0x28, 0x55)
                    new_style.paragraph_format.space_before = Pt(8)
                    new_style.paragraph_format.space_after = Pt(4)
                elif style_name == "subsection":
                    new_style.font.name = "Bebas Neue"
                    new_style.font.size = Pt(18)
                    new_style.font.bold = True
                    new_style.font.color.rgb = RGBColor(0x00, 0x28, 0x55)
                    new_style.paragraph_format.space_before = Pt(8)
                    new_style.paragraph_format.space_after = Pt(4)
                elif style_name == "subsubsection":
                    new_style.font.name = "Bebas Neue"
                    new_style.font.size = Pt(14)
                    new_style.font.bold = True
                    new_style.font.color.rgb = RGBColor(0x00, 0x28, 0x55)
                    new_style.paragraph_format.space_before = Pt(4)
                    new_style.paragraph_format.space_after = Pt(0)
                elif style_name in {"enumerate", "itemize", "text"}:
                    new_style.font.name = "Calibri"
                    new_style.font.size = Pt(11)
                    new_style.paragraph_format.space_before = Pt(0)
                    new_style.paragraph_format.space_after = Pt(0)
                # Now apply the newly created style
                para.style = style_name
            except Exception:
                # If creation fails, fall back to Normal
                para.style = "Normal"

    def convert_to_word(self, content: LatexReport) -> DocumentObject:
        r"""
        Convert a LaTeX string (with text, equations, titles, sections, subsections, tables) to a Word Document object.
        Args:
            content: The report to convert.

        Returns
        -------
            The python-docx Document object (not saved).
        """
        # Create a new Document
        doc = Document()

        # Convert content to string
        content_str = content.content if hasattr(content, "content") else str(content)

        # Preprocess to remove LaTeX preamble commands
        content_str = self._preprocess_content(content_str)

        matches = self._extract_structural_elements(content_str)
        parsed = self._build_parsed_content(content_str, matches)
        self._add_content_to_document(doc, parsed)
        return doc

    @staticmethod
    def _preprocess_content(content: str) -> str:
        """Remove LaTeX preamble and document structure commands that should be ignored.

        Args:
            content: The raw LaTeX string.

        Returns
        -------
            Cleaned content with preamble and document structure removed
        """
        # Remove everything before and including \begin{document}
        begin_match = re.search(r"\\begin\{document\}", content)
        if begin_match:
            content = content[begin_match.end() :]

        # Remove everything after and including \end{document}
        end_match = re.search(r"\\end\{document\}", content)
        if end_match:
            content = content[: end_match.start()]

        # Remove \date{...} commands
        content = re.sub(r"\\date\{.*?\}", "", content)

        # Remove \maketitle commands
        content = re.sub(r"\\maketitle", "", content)

        return content.strip()

    @staticmethod
    def _extract_structural_elements(content: str) -> list[dict[str, str | int]]:
        """Extract structural elements (titles, sections, tables) from LaTeX content.

        Args:
            content: The LaTeX string to parse.

        Returns
        -------
            A list of dictionaries containing type, content, start, and end positions.
        """
        # Patterns for all elements
        patterns: list[tuple[str, str, int]] = [
            ("title", r"\\title\{(.*?)\}", 0),
            ("section", r"\\section\{(.*?)\}", 0),
            ("subsection", r"\\subsection\{(.*?)\}", 0),
            ("subsubsection", r"\\subsubsection\{(.*?)\}", 0),
            ("table", r"\\begin\{table\}.*?\\end\{table\}", re.DOTALL),
            ("figure", r"\\begin\{figure\}.*?\\end\{figure\}", re.DOTALL),
            ("itemize", r"\\begin\{itemize\}.*?\\end\{itemize\}", re.DOTALL),
            ("enumerate", r"\\begin\{enumerate\}.*?\\end\{enumerate\}", re.DOTALL),
        ]

        # Find all elements and their positions
        matches: list[dict[str, str | int]] = []
        for element_type, pattern, flags in patterns:
            matches.extend(
                {
                    "type": element_type,
                    "content": match.group(1) if element_type not in ("table", "figure", "itemize", "enumerate") else match.group(0),
                    "start": match.start(),
                    "end": match.end(),
                }
                for match in re.finditer(pattern, content, flags)
            )

        # Sort by position
        matches.sort(key=lambda x: int(x["start"]))
        return matches

    def _build_parsed_content(self, content: str, matches: list[dict[str, str | int]]) -> list[dict[str, str | bool]]:
        """Build parsed content list from structural elements and text/equations.

        Args:
            content: The original LaTeX string.
            matches: List of structural elements with their positions.

        Returns
        -------
            A list of parsed content items (text, equations, headings, tables).
        """
        parsed = []
        last_idx = 0

        for match in matches:
            # Text/equation between previous and current match
            start_pos = int(match["start"])
            end_pos = int(match["end"])
            if start_pos > last_idx:
                between = content[last_idx:start_pos]
                parsed.extend(self._parse_text_and_equations(between))
            parsed.append({"type": str(match["type"]), "content": str(match["content"])})
            last_idx = end_pos

        # Remaining text/equation after last match
        if last_idx < len(content):
            parsed.extend(self._parse_text_and_equations(content[last_idx:]))

        return parsed

    def _add_content_to_document(self, doc: DocumentObject, parsed: list[dict[str, str | bool]]) -> None:
        """Add parsed content items to the Word document.

        Args:
            doc: The Word Document object to add content to.
            parsed: List of parsed content items.
        """
        i = 0  # Index to track position in parsed list
        while i < len(parsed):
            item = parsed[i]
            item_type = str(item["type"])

            if item_type == "text":
                i = self._add_grouped_text(doc, parsed, i)
            elif item_type == "equation":
                self._add_equation(doc, str(item["content"]))
                i += 1
            elif item_type == "newline":
                self._add_newline(doc)
                i += 1
            elif item_type in ("title", "section", "subsection", "subsubsection"):
                self._add_heading(doc, item_type, str(item["content"]))
                i += 1
            elif item_type == "table":
                self._add_table_to_doc(doc, str(item["content"]))
                i += 1
            elif item_type == "figure":
                self._add_figure_to_doc(doc, str(item["content"]))
                i += 1
            elif item_type == "itemize":
                self._add_itemize_to_doc(doc, str(item["content"]))
                i += 1
            elif item_type == "enumerate":
                self._add_enumerate_to_doc(doc, str(item["content"]))
                i += 1
            else:
                raise ValueError(f"Unknown content type: {item_type}")

    def _add_grouped_text(self, doc: DocumentObject, parsed: list[dict[str, str | bool]], start_index: int) -> int:
        """Group consecutive text items into a single paragraph.

        Args:
            doc: The Word Document object.
            parsed: List of parsed content items.
            start_index: Starting index in parsed list.

        Returns
        -------
            Updated index after processing text items.
        """
        para = doc.add_paragraph()
        self._set_style(para, "text")

        i = start_index
        while i < len(parsed) and str(parsed[i]["type"]) == "text":
            text_item = parsed[i]
            content = str(text_item["content"])
            bold = bool(text_item.get("bold", False))
            italic = bool(text_item.get("italic", False))
            self._add_text_with_inline_math(para, content, bold=bold, italic=italic)
            i += 1

        # Skip the first newline after text (it just ends the paragraph)
        if i < len(parsed) and str(parsed[i]["type"]) == "newline":
            i += 1

        return i

    def _add_heading(self, doc: DocumentObject, heading_type: str, content: str) -> None:
        """Add a heading to the document.

        Args:
            doc: The Word Document object.
            heading_type: Type of heading ('title', 'section', 'subsection', or 'subsubsection').
            content: The text content of the heading.
        """
        para = doc.add_paragraph(content)
        self._set_style(para, heading_type)

    def _add_newline(self, doc: DocumentObject) -> None:
        """Add a paragraph break (empty paragraph) to the document.

        Args:
            doc: The Word Document object.
        """
        para = doc.add_paragraph()
        self._set_style(para, "text")

    def _add_text_with_inline_math(self, para: Paragraph, content: str, bold: bool = False, italic: bool = False) -> None:
        """Add text with inline math ($...$) to a paragraph, applying bold/italic as needed.

        Args:
            para: The paragraph object to add content to.
            content: The text content that may contain inline math ($...$).
            bold: Whether to apply bold formatting to text runs.
            italic: Whether to apply italic formatting to text runs.
        """
        # Split content by inline math ($...$)
        parts = re.split(r"(\$.*?\$)", content)
        for part in parts:
            if part.startswith("$") and part.endswith("$"):
                # Inline equation
                latex_eq = part[1:-1]
                para._p.append(self._formula(latex_eq.replace(r"\%", "%")))  # noqa: SLF001
            elif part:
                run = para.add_run(part.replace(r"\%", "%"))
                run.bold = bold
                run.italic = italic

    def _add_equation(self, doc: DocumentObject, content: str) -> None:
        r"""Add an equation to the document.

        If the equation is longer than 150 characters, split it on every '=' (except the first),
        or on every '\to' (except the first), whichever comes first.

        Args:
            doc: The Word Document object.
            content: The LaTeX equation content.
        """
        if len(content) > 150:
            # Find all split points: '=', '\to'
            split_pattern = r"(=|\\to)"
            parts = re.split(split_pattern, content)
            # Find the first split point (if any)
            if len(parts) > 3:
                first = parts[0] + parts[1] + parts[2]
                rest = parts[3:]
                segments = [first]
                for i in range(0, len(rest), 2):
                    seg = "".join(rest[i : i + 2])
                    if seg:
                        segments.append(seg)
            else:
                segments = [content]
            for seg in segments:
                if seg.strip():
                    p = doc.add_paragraph()
                    p._p.append(self._formula(seg.strip()))  # noqa: SLF001
        else:
            p = doc.add_paragraph()
            p._p.append(self._formula(content))  # noqa: SLF001

    def _add_table_to_doc(self, doc: DocumentObject, table_latex: str) -> None:
        """Parse LaTeX table and add it to the Word document.

        Args:
            doc: The Word Document object.
            table_latex: LaTeX string containing a table environment.
        """
        rows_data = self._parse_table_content(table_latex)

        # Create Word table
        num_rows = len(rows_data)
        num_cols = max(len(row) for row in rows_data) if rows_data else 0

        table = doc.add_table(rows=num_rows, cols=num_cols)

        # Fill table cells (supporting inline math)
        for i, row_data in enumerate(rows_data):
            for j, cell_content in enumerate(row_data):
                if j < num_cols:
                    cell = table.rows[i].cells[j]
                    # Clear default paragraph and add content with inline math support
                    cell.text = ""
                    para = cell.paragraphs[0]
                    self._set_style(para, "text")
                    # Make top row bold
                    is_bold = i == 0
                    self._add_text_with_inline_math(para, cell_content, bold=is_bold)

    def _add_figure_to_doc(self, doc: DocumentObject, figure_latex: str) -> None:
        """Parse LaTeX figure and add it to the Word document.

        Args:
            doc: The Word Document object.
            figure_latex: LaTeX string containing a figure environment.
        """
        figure_info = self._parse_figure_content(figure_latex)

        if not figure_info or not figure_info.get("image_path"):
            # If no valid figure info, add a placeholder paragraph
            para = doc.add_paragraph()
            run = para.add_run("[Figure placeholder - image not found]")
            run.italic = True
            return

        # Add the image to the document
        para = doc.add_paragraph()
        run = para.add_run()

        # Get width from figure info (default to 3 inches if not specified)
        width = figure_info.get("width_inches", 3.0)

        # Add picture to the run
        run.add_picture(figure_info["image_path"], width=Inches(width))

        # Center the paragraph
        para.alignment = 1  # 1 = center alignment

    def _add_itemize_to_doc(self, doc: DocumentObject, itemize_latex: str) -> None:
        """Parse LaTeX itemize list and add it to the Word document.

        Args:
            doc: The Word Document object.
            itemize_latex: LaTeX string containing an itemize environment.
        """
        items = self._parse_itemize_content(itemize_latex)

        for item_content in items:
            para = doc.add_paragraph()
            self._set_style(para, "itemize")
            # Clear default text and add content with inline math support
            para.text = ""
            # Add the bullet prefix
            para.add_run("â€¢     ")
            self._add_text_with_inline_math(para, item_content)

    def _add_enumerate_to_doc(self, doc: DocumentObject, enumerate_latex: str) -> None:
        """Parse LaTeX enumerate list and add it to the Word document.

        Args:
            doc: The Word Document object.
            enumerate_latex: LaTeX string containing an enumerate environment.
        """
        items = self._parse_enumerate_content(enumerate_latex)

        for idx, item_content in enumerate(items, start=1):
            para = doc.add_paragraph()
            self._set_style(para, "enumerate")
            # Clear default text and add content with inline math support
            para.text = ""
            # Add the number prefix
            para.add_run(f"{idx}.    ")
            self._add_text_with_inline_math(para, item_content)

    @staticmethod
    def _formula(latex_string: str) -> BaseOxmlElement:
        """Convert a LaTeX equation string (already in math mode) to an OMML XML element for Word.

        Args:
            latex_string: The LaTeX string representing the equation.

        Returns
        -------
            BaseOxmlElement containing the OMML representation of the equation.
        """
        mathml_output = latex2mathml.converter.convert(latex_string)
        omml_output = mathml2omml.convert(mathml_output)
        xml_output = f'<m:oMathPara xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math">{omml_output}</m:oMathPara>'
        return parse_xml(xml_output)[0]

    @staticmethod
    def _parse_text_and_equations(text: str) -> list[dict[str, str | bool]]:
        r"""Parse text containing both inline text and equation environments.

        Args:
            text: LaTeX string that may contain \begin{equation}...\end{equation} blocks.

        Returns
        -------
            List of dictionaries representing text and equation items.
        """
        result: list[dict[str, str | bool]] = []

        # First, handle equation environments
        equation_pattern = r"\\begin\{equation\}(.*?)\\end\{equation\}"
        equation_matches = list(re.finditer(equation_pattern, text, re.DOTALL))

        if equation_matches:
            last_idx = 0
            for equation_match in equation_matches:
                # Process text before equation
                before_text = text[last_idx : equation_match.start()]
                if before_text.strip():
                    result.extend(ReportToWordConverter._parse_inline_content(before_text))

                # Process equation
                equation_content = equation_match.group(1).strip()

                # Extract tag if present
                tag_match = re.search(r"\\tag\{(.*?)\}", equation_content)

                # Remove \tag{...} from equation content
                if tag_match:
                    tag = tag_match.group(1)
                    equation_content = equation_content[: tag_match.start()] + equation_content[tag_match.end() :]
                    equation_content = equation_content.strip()
                    # Append tag as text to the right of the equation
                    equation_content += r"\text{   (" + tag + r")}"

                equation_item: dict[str, str | bool] = {"type": "equation", "content": equation_content}
                result.append(equation_item)

                last_idx = equation_match.end()

            # Process remaining text after last equation
            remaining = text[last_idx:]
            if remaining.strip():
                result.extend(ReportToWordConverter._parse_inline_content(remaining))
        else:
            # No equation environments, process as inline content
            result.extend(ReportToWordConverter._parse_inline_content(text))

        return result

    @staticmethod
    def _parse_inline_content(text: str) -> list[dict[str, str | bool]]:
        """Parse text (can contain inline text formula and newlines).

        Args:
            text: LaTeX string without equation environments.

        Returns
        -------
            List of dictionaries representing text, inline equation items, and newlines.
        """
        # First, parse newlines
        return ReportToWordConverter._parse_newline(text)

    @staticmethod
    def _parse_newline(text: str) -> list[dict[str, str | bool]]:
        r"""Parse text containing newlines and text blocks.

        Args:
            text: LaTeX string that may contain \newline commands.

        Returns
        -------
            List of dictionaries representing text items and newlines.
        """
        result: list[dict[str, str | bool]] = []

        # Split by \newline
        parts = re.split(r"(\\newline)", text)

        for part in parts:
            if part == r"\newline":
                # Add a newline item
                result.append({"type": "newline"})
            elif part.strip():  # Only process non-empty parts
                # Parse text blocks from this part
                result.extend(ReportToWordConverter._parse_text_blocks(part))

        return result

    @staticmethod
    def _parse_text_blocks(text: str) -> list[dict[str, str | bool]]:
        r"""Parse text blocks (\textbf, \textit, \text).

        Args:
            text: LaTeX string without equation environments or newlines.

        Returns
        -------
            List of dictionaries representing text items.
        """
        result: list[dict[str, str | bool]] = []
        # Pattern matches \textbf{...}, \textit{...}, \text{...} with nested braces
        pattern = (
            r"\\textbf\{((?:[^{}]|\{[^{}]*\})*)\}"
            r"|\\textit\{((?:[^{}]|\{[^{}]*\})*)\}"
            r"|\\text\{((?:[^{}]|\{[^{}]*\})*)\}"
        )
        for match in re.finditer(pattern, text):
            bold_content = match.group(1)
            italic_content = match.group(2)
            text_content = match.group(3)
            if bold_content is not None:
                content = bold_content
                bold, italic = True, r"\textit{" in content
                if italic:
                    nested = re.search(r"\\textit\{((?:[^{}]|\{[^{}]*\})*)\}", content)
                    if nested:
                        content = nested.group(1)
                result.append({"type": "text", "content": content, "bold": bold, "italic": italic})
            elif italic_content is not None:
                content = italic_content
                bold, italic = r"\textbf{" in content, True
                if bold:
                    nested = re.search(r"\\textbf\{((?:[^{}]|\{[^{}]*\})*)\}", content)
                    if nested:
                        content = nested.group(1)
                result.append({"type": "text", "content": content, "bold": bold, "italic": italic})
            elif text_content is not None:
                result.append({"type": "text", "content": text_content, "bold": False, "italic": False})
        return result

    @staticmethod
    def _parse_table_content(table_latex: str) -> list[list[str]]:
        """Parse LaTeX table content into rows and columns.

        Args:
            table_latex: LaTeX string containing a table environment.

        Returns
        -------
            List of rows, where each row is a list of cell contents.
        """
        # Extract tabular content
        tabular_match = re.search(r"\\begin\{tabular\}\{.*?\}(.*?)\\end\{tabular\}", table_latex, re.DOTALL)
        if not tabular_match:
            return []
        tabular_content = tabular_match.group(1)

        # Remove LaTeX table commands
        tabular_content = re.sub(r"\\toprule|\\midrule|\\bottomrule|\\hline|\\centering", "", tabular_content)

        # Split by rows (\\)
        rows = re.split(r"\\\\", tabular_content)

        parsed_rows = []
        for row in rows:
            row_stripped = row.strip()
            if not row_stripped:
                continue
            # Split by columns (&)
            cells = row_stripped.split("&")
            parsed_cells = []
            for cell in cells:
                cell_stripped = cell.strip()
                # Extract text from \text{...} blocks while preserving inline math
                # Handle nested braces: match \text{...} with up to one level of nested braces
                cell_content = re.sub(r"\\text\{((?:[^{}]|\{[^{}]*\})*)\}", r"\1", cell_stripped)
                parsed_cells.append(cell_content)
            if parsed_cells:
                parsed_rows.append(parsed_cells)

        return parsed_rows

    @staticmethod
    def _parse_figure_content(figure_latex: str) -> dict[str, str | float] | None:
        """Parse LaTeX figure content to extract image path and properties.

        Args:
            figure_latex: LaTeX string containing a figure environment.

        Returns
        -------
            Dictionary with image_path and optional width_inches, or None if no valid image found.
        """
        # Extract includegraphics command
        # Pattern: \includegraphics[options]{filename}
        includegraphics_pattern = r"\\includegraphics(?:\[(.*?)\])?\{(.*?)\}"
        match = re.search(includegraphics_pattern, figure_latex)

        if not match:
            return None

        options_str = match.group(1) if match.group(1) else ""
        image_path = match.group(2).strip()

        result: dict[str, str | float] = {"image_path": image_path}

        # Parse options for width
        if options_str:
            # Look for width specification (e.g., width=0.5\textwidth)
            width_match = re.search(r"width\s*=\s*([0-9.]+)\\textwidth", options_str)
            if width_match:
                width_factor = float(width_match.group(1))
                # Convert to inches (assume textwidth is ~6.5 inches for standard document)
                result["width_inches"] = width_factor * 6.5
            else:
                # Look for explicit width in other units
                width_explicit = re.search(r"width\s*=\s*([0-9.]+)\s*(in|cm|mm|pt)", options_str)
                if width_explicit:
                    value = float(width_explicit.group(1))
                    unit = width_explicit.group(2)
                    # Convert to inches
                    if unit == "in":
                        result["width_inches"] = value
                    elif unit == "cm":
                        result["width_inches"] = value / 2.54
                    elif unit == "mm":
                        result["width_inches"] = value / 25.4
                    elif unit == "pt":
                        result["width_inches"] = value / 72.0

        return result

    @staticmethod
    def _parse_itemize_content(itemize_latex: str) -> list[str]:
        """Parse LaTeX itemize content into individual items.

        Args:
            itemize_latex: LaTeX string containing an itemize environment.

        Returns
        -------
            List of item contents as strings.
        """
        # Extract content between \begin{itemize} and \end{itemize}
        content_match = re.search(r"\\begin\{itemize\}(.*?)\\end\{itemize\}", itemize_latex, re.DOTALL)
        if not content_match:
            return []

        content = content_match.group(1).strip()

        # Split by \item and extract each item's content
        items = re.split(r"\\item", content)

        # Filter out empty items and strip whitespace
        parsed_items = []
        for item in items:
            item_stripped = item.strip()
            if item_stripped:
                # Extract text from \text{...} blocks while preserving inline math
                item_content = re.sub(r"\\text\{((?:[^{}]|\{[^{}]*\})*)\}", r"\1", item_stripped)
                parsed_items.append(item_content)

        return parsed_items

    @staticmethod
    def _parse_enumerate_content(enumerate_latex: str) -> list[str]:
        """Parse LaTeX enumerate content into individual items.

        Args:
            enumerate_latex: LaTeX string containing an enumerate environment.

        Returns
        -------
            List of item contents as strings.
        """
        # Extract content between \begin{enumerate} and \end{enumerate}
        content_match = re.search(r"\\begin\{enumerate\}(.*?)\\end\{enumerate\}", enumerate_latex, re.DOTALL)
        if not content_match:
            return []

        content = content_match.group(1).strip()

        # Split by \item and extract each item's content
        items = re.split(r"\\item", content)

        # Filter out empty items and strip whitespace
        parsed_items = []
        for item in items:
            item_stripped = item.strip()
            if item_stripped:
                # Extract text from \text{...} blocks while preserving inline math
                item_content = re.sub(r"\\text\{((?:[^{}]|\{[^{}]*\})*)\}", r"\1", item_stripped)
                parsed_items.append(item_content)

        return parsed_items
